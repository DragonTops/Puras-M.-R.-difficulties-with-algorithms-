# Отчет по лабораторной работе 4
# Алгоритмы сортировки

**Дата:** 15-12-2025  
**Семестр:** 3 курс 1 полугодие  
**Группа:** ПИЖ-б-о-23-1  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Пурас М.Р.

## Цель работы
Изучить и реализовать основные алгоритмы сортировки. Провести их теоретический и практический сравнительный анализ по временной и пространственной сложности. Исследовать влияние начальной упорядоченности данных на эффективность алгоритмов.

## Теоретическая часть
Рассмотрены следующие алгоритмы сортировки:

- **Сортировка пузырьком (Bubble Sort):** Сложность O(n²) во всех случаях
- **Сортировка выбором (Selection Sort):** Сложность O(n²)
- **Сортировка вставками (Insertion Sort):** O(n²) в худшем и среднем, O(n) в лучшем случае
- **Сортировка слиянием (Merge Sort):** O(n log n) во всех случаях, требует O(n) дополнительной памяти
- **Быстрая сортировка (Quick Sort):** O(n log n) в среднем, O(n²) в худшем случае

## Практическая часть

### Выполненные задачи
- [x] Реализация 5 алгоритмов сортировки
- [x] Генерация тестовых данных разных типов
- [x] Замер времени выполнения алгоритмов
- [x] Визуализация результатов
- [x] Сравнительный анализ эффективности

### Ключевые фрагменты кода

#### Реализация быстрой сортировки
```python
def quick_sort(arr: List[int]) -> List[int]:
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

#### Генерация тестовых данных
```python
def generate_almost_sorted(size: int, disorder_percentage: float = 0.05) -> List[int]:
    arr = list(range(size))
    num_disorder = int(size * disorder_percentage)
    for _ in range(num_disorder):
        i, j = random.sample(range(size), 2)
        arr[i], arr[j] = arr[j], arr[i]
    return arr
```

## Результаты выполнения

### Пример работы программы
```bash
Тестирование на массиве из 1000 элементов:
Bubble Sort: 0.215 сек
Selection Sort: 0.134 сек  
Insertion Sort: 0.089 сек
Merge Sort: 0.012 сек
Quick Sort: 0.008 сек
```

### Сравнительная таблица производительности (мс)
| Алгоритм | n=100 | n=1000 | n=5000 | n=10000 |
|----------|-------|--------|--------|---------|
| Bubble Sort | 1.2 | 215 | 5400 | 21500 |
| Selection Sort | 0.8 | 134 | 3200 | 12800 |
| Insertion Sort | 0.5 | 89 | 2100 | 8500 |
| Merge Sort | 0.1 | 12 | 85 | 180 |
| Quick Sort | 0.08 | 8 | 45 | 95 |

## Выводы
1. **Сортировка вставками** эффективна для маленьких или почти отсортированных массивов
2. **Быстрая сортировка** - лучший выбор в среднем случае для больших данных
3. **Сортировка слиянием** стабильна и предсказуема по времени, но требует дополнительной памяти
4. Простые алгоритмы (пузырьком, выбором) практичны только для небольших наборов данных
