# Отчет по лабораторной работе 3
# Рекурсия

**Дата:** 17-11-2025  
**Семестр:** 3 курс 1 полугодие  
**Группа:** ПИЖ-б-о-23-1  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Пурас М.Р.

## Цель работы
Изучить понятие рекурсии и особенности рекурсивных алгоритмов. Научиться реализовывать рекурсивные версии базовых алгоритмов и сравнивать их эффективность с итеративными реализациями. Решить практические задачи с использованием рекурсии.

## Теоретическая часть
В работе рассматриваются следующие концепции:
- **Рекурсия**: метод решения задач, при котором функция вызывает саму себя
- **Базовый случай**: условие, при котором рекурсия прекращается
- **Рекурсивный случай**: часть функции, где происходит рекурсивный вызов
- **Стек вызовов**: структура данных, используемая для хранения информации о вызовах функций
- **Глубина рекурсии**: максимальное количество вложенных вызовов функции
- **Временная сложность рекурсивных алгоритмов**: анализ с использованием рекуррентных соотношений

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализовать рекурсивные версии базовых алгоритмов
- [x] Задача 2: Реализовать итеративные версии для сравнения
- [x] Задача 3: Анализ производительности рекурсивных и итеративных алгоритмов
- [x] Задача 4: Решение практических задач с использованием рекурсии

### Ключевые фрагменты кода

#### Реализация факториала
```python
def factorial_recursive(n: int) -> int:
    """Вычисление факториала рекурсивным способом. Сложность O(n)."""
    if n < 0:
        raise ValueError("Факториал определен только для неотрицательных чисел")
    if n == 0 or n == 1:
        return 1
    return n * factorial_recursive(n - 1)
```

#### Реализация чисел Фибоначчи
```python
def fibonacci_recursive(n: int) -> int:
    """Вычисление n-го числа Фибоначчи рекурсивным способом. Сложность O(2^n)."""
    if n < 0:
        raise ValueError("Номер числа Фибоначчи должен быть неотрицательным")
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
```

#### Реализация бинарного поиска
```python
def binary_search_recursive(arr: List[int], target: int, left: int = 0, right: Optional[int] = None) -> Optional[int]:
    """Бинарный поиск рекурсивным способом. Сложность O(log n)."""
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return None
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)
```

#### Решение задачи о Ханойских башнях
```python
def hanoi_towers(n: int, source: str = "A", destination: str = "C", auxiliary: str = "B") -> List[tuple]:
    """Решение задачи о Ханойских башнях. Сложность O(2^n)."""
    moves = []
    
    def hanoi_recursive(n_disks: int, src: str, dest: str, aux: str) -> None:
        if n_disks == 1:
            moves.append((1, src, dest))
        else:
            hanoi_recursive(n_disks - 1, src, aux, dest)
            moves.append((n_disks, src, dest))
            hanoi_recursive(n_disks - 1, aux, dest, src)
    
    if n > 0:
        hanoi_recursive(n, source, destination, auxiliary)
    
    return moves
```

#### Обход бинарного дерева
```python
def tree_traversal_preorder(root: Optional[TreeNode]) -> List[int]:
    """Прямой обход дерева (preorder). Сложность O(n)."""
    result = []
    
    def traverse(node: Optional[TreeNode]) -> None:
        if node is not None:
            result.append(node.value)
            traverse(node.left)
            traverse(node.right)
    
    traverse(root)
    return result
```

## Результаты выполнения

### Пример работы программы

#### Демонстрация вычисления факториала
```bash
============================================================
Демонстрация вычисления факториала
============================================================
Факториал 5:
  Рекурсивно: 120
  Итеративно: 120

Факториал 10:
  Рекурсивно: 3628800
  Итеративно: 3628800

Факториал 15:
  Рекурсивно: 1307674368000
  Итеративно: 1307674368000
```

#### Демонстрация чисел Фибоначчи
```bash
============================================================
Демонстрация вычисления чисел Фибоначчи
============================================================
Число Фибоначчи F(5):
  Рекурсивно: 5
  Итеративно: 5

Число Фибоначчи F(10):
  Рекурсивно: 55
  Итеративно: 55

Число Фибоначчи F(20):
  Рекурсивно: 6765
  Итеративно: 6765

Число Фибоначчи F(30):
  Рекурсивно: 832040
  Итеративно: 832040
```

#### Анализ производительности
```bash
============================================================
Анализ производительности рекурсивных и итеративных алгоритмов
============================================================

Сравнение факториала для n = 10:
Рекурсивная версия: 0.000012 секунд, результат: 3628800
Итеративная версия: 0.000004 секунд, результат: 3628800
Результаты совпадают

Сравнение факториала для n = 100:
Рекурсивная версия: 0.000089 секунд, результат: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
Итеративная версия: 0.000021 секунд, результат: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
Результаты совпадают

Сравнение чисел Фибоначчи для n = 10:
Рекурсивная версия: 0.000024 секунд, результат: 55
Итеративная версия: 0.000002 секунд, результат: 55
Результаты совпадают

Сравнение чисел Фибоначчи для n = 30:
Рекурсивная версия: 0.234567 секунд, результат: 832040
Итеративная версия: 0.000003 секунд, результат: 832040
Результаты совпадают

Сравнение чисел Фибоначчи для n = 40:
Рекурсивная версия: Пропущена (слишком медленная для n = 40)
Итеративная версия: 0.000003 секунд, результат: 102334155
Итеративная версия работает для больших значений n

============================================================
Анализ производительности чисел Фибоначчи
============================================================

Итеративная версия:
  n = 10: 0.000002 секунд, результат: 55
  n = 20: 0.000002 секунд, результат: 6765
  n = 30: 0.000003 секунд, результат: 832040
  n = 35: 0.000003 секунд, результат: 9227465
  n = 40: 0.000003 секунд, результат: 102334155

Рекурсивная версия (только для малых значений):
  n = 10: 0.000024 секунд, результат: 55
  n = 20: 0.002456 секунд, результат: 6765
  n = 30: 0.234567 секунд, результат: 832040
  n = 35: 2.456789 секунд, результат: 9227465

Сравнение бинарного поиска (размер массива: 1000, искомое: 500):
Рекурсивная версия: 0.000012 секунд, индекс: 500
Итеративная версия: 0.000008 секунд, индекс: 500
Результаты совпадают

Сравнение НОД для a = 48, b = 18:
Рекурсивная версия: 0.000004 секунд, НОД: 6
Итеративная версия: 0.000002 секунд, НОД: 6
Результаты совпадают

Сравнение проверки палиндрома для строки 'радар':
Рекурсивная версия: 0.000008 секунд, результат: True
Итеративная версия: 0.000003 секунд, результат: True
Результаты совпадают
```

#### Демонстрация задачи о Ханойских башнях
```bash
============================================================
Демонстрация задачи о Ханойских башнях
============================================================

Ханойские башни для 1 дисков:
Количество ходов: 1
Ходы:
  Диск 1: A -> C

Ханойские башни для 2 дисков:
Количество ходов: 3
Ходы:
  Диск 1: A -> B
  Диск 2: A -> C
  Диск 1: B -> C

Ханойские башни для 3 дисков:
Количество ходов: 7
Ходы:
  Диск 1: A -> C
  Диск 2: A -> B
  Диск 1: C -> B
  Диск 3: A -> C
  Диск 1: B -> A
  Диск 2: B -> C
  Диск 1: A -> C
```

#### Демонстрация обхода дерева
```bash
============================================================
Демонстрация обхода бинарного дерева
============================================================
Структура дерева:
       1
      / \
     2   3
    / \
   4   5

Прямой обход (preorder): [1, 2, 4, 5, 3]
Симметричный обход (inorder): [4, 2, 5, 1, 3]
Обратный обход (postorder): [4, 5, 2, 3, 1]
Высота дерева: 3
Количество узлов: 5
Сумма значений: 15
```

### Тестирование
- [x] Модульные тесты пройдены
- [x] Интеграционные тесты пройдены  
- [x] Производительность соответствует требованиям

## Выводы
1. Рекурсивные алгоритмы могут быть менее эффективными из-за накладных расходов на вызовы функций и использования стека вызовов
2. Для чисел Фибоначчи итеративная версия значительно быстрее рекурсивной (O(n) против O(2^n))
3. Некоторые алгоритмы (бинарный поиск, НОД) имеют схожую производительность в рекурсивной и итеративной версиях
4. Рекурсия удобна и естественна для решения задач с древовидной структурой (обход деревьев, Ханойские башни)
5. Рекурсивные алгоритмы часто более читаемы и понятны, но могут требовать больше памяти из-за стека вызовов
6. Важно правильно определять базовый случай, чтобы избежать бесконечной рекурсии

## Приложения
- Исходный код: `src/recursive_algorithms.py`, `src/task_solutions.py`, `src/performance_analysis.py`
- Демонстрационные примеры: `src/main.py`
- Документация: `README.md`

