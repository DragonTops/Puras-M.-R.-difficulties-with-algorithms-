# Лабораторная работа 9: Динамическое программирование

## Описание проекта
Исследование и реализация методов динамического программирования. Сравнение нисходящего и восходящего подходов, анализ производительности и решение практических задач.

## Цели работы
- Изучить метод динамического программирования как инструмент решения сложных задач
- Освоить нисходящий (с мемоизацией) и восходящий (табличный) подходы
- Реализовать классические алгоритмы ДП
- Провести сравнительный анализ эффективности подходов
- Решить практические задачи с применением ДП

## Структура проекта
```
lab-09-Динамическое_программирование/
├── src/                    # Исходный код
│   ├── dynamic_programming.py # Реализация алгоритмов ДП
│   ├── comparison.py       # Сравнительный анализ
│   └── task_solutions.py   # Решение практических задач
├── tests/                  # Модульные тесты
├── docs/                   # Документация
├── pics/                   # Графики и визуализации
├── README.md               # Этот файл
├── ОТЧЕТ.md               # Полный отчет о работе
└── requirements.txt        # Зависимости
```

## Быстрый старт

### Установка и запуск
```bash
# Клонирование репозитория
git clone https://github.com/FamiliyaIO/algorithms-lab-09.git
cd algorithms-lab-09

# Запуск алгоритмов ДП
python src/dynamic_programming.py

# Запуск сравнительного анализа
python src/comparison.py

# Запуск решения практических задач
python src/task_solutions.py
```

### Требования
- Python 3.8 или выше
- Библиотеки: matplotlib, numpy (установить через requirements.txt)

## Основные функции

### Реализованные алгоритмы ДП
- **Числа Фибоначчи** (наивная рекурсия, мемоизация, табличный метод)
- **Задача о рюкзаке 0-1** (восходящий подход)
- **Наибольшая общая подпоследовательность** (LCS)
- **Расстояние Левенштейна**
- **Размен монет** (минимальное количество монет)
- **Наибольшая возрастающая подпоследовательность** (LIS)

### Сравнительный анализ
- Сравнение времени работы нисходящего и восходящего подходов
- Анализ потребления памяти
- Сравнение с жадными алгоритмами

### Практические задачи
1. **Размен монет** - нахождение минимального количества монет для суммы
2. **LIS** - поиск наибольшей возрастающей подпоследовательности
3. **Восстановление решения** для LCS и задачи о рюкзаке

## Критерии выполнения

### Обязательные требования
- [x] Реализация 4+ алгоритмов ДП
- [x] Оба подхода (мемоизация и табличный) для Фибоначчи
- [x] Сравнительный анализ подходов ДП
- [x] Решение 3+ практических задач
- [x] Восстановление решения для LCS/рюкзака
- [x] Соответствие кода PEP8 с аннотациями типов
- [x] Полный отчет с выводами и графиками

### Теоретическая база
- Принципы динамического программирования
- Оптимальная подструктура и перекрывающиеся подзадачи
- Временная и пространственная сложность
- Нисходящий и восходящий подходы

## Использование

### Пример вычисления Фибоначчи
```python
from src.dynamic_programming import fibonacci_memo, fibonacci_tabular

result_memo = fibonacci_memo(10)    # Нисходящий подход
result_tabular = fibonacci_tabular(10)  # Восходящий подход
```

### Пример задачи о рюкзаке
```python
from src.dynamic_programming import knapsack_01

weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 5
result = knapsack_01(weights, values, capacity)  # Макс. стоимость: 7
```

## Результаты

### Производительность алгоритмов
| Алгоритм | Временная сложность | Пространственная сложность |
|----------|---------------------|----------------------------|
| Фибоначчи (мемоизация) | O(n) | O(n) |
| Фибоначчи (табличный) | O(n) | O(n) |
| Рюкзак 0-1 | O(n×W) | O(n×W) |
| LCS | O(m×n) | O(m×n) |

### Ключевые выводы
1. Нисходящий подход проще в реализации для рекурсивных задач
2. Восходящий подход эффективнее по памяти для некоторых задач
3. ДП оптимально для задач с оптимальной подструктурой